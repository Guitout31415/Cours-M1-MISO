#2.1 Vecteurs
a<-c(5.4,2.1,16,89) #Créer un vecteur a contenant 5.4,2.1,16 et 89
a #Donne les éléments de a
b<-c(a,6,1) #Créer un vecteur b contenant les éléments de a, puis 6, puis 1
d<-c(a,3,2,a) #Créer un vecteur d contenant les éléments de a, puis 3, puis 2, puis de nouveau les éléments de a
a[2] #Donne le 2ème élément du vecteur a
is.vector(a) #Renvoie TRUE si a est un vecteur, FALSE sinon
e<-a[2:4] #Créer un vecteur e contenant le 2ème, 3ème et 4ème éléments de a
f<-1:12 #Créer un vecteur f contenant tout les entiers de 1 à 12
f[2:3] #Donne les 2ème et 3ème éléments de f
f[5] #Donne le 5ème élément de f
f[-5] #Donne f privé de son 5ème élément
g<-c(3,6,1,"a") #Créer un vecteur g contenant "3", "6", "1" et "a" car "a" est une chaîne de caractère
g<-c(T,F,T,T) #Créer un vecteur g contenant TRUE, FALSE, TRUE, TRUE
mode(g) #Donne le type de g
h=seq(from=1,to=5,by=0.5) #Créer un vecteur h contenant tout les nombres entre 1 et 5 avec un pas de 0.5
h=seq(from=1,to=5,length=9) #Créer un vecteur h de longueur 9 contenant tout les nombres entres 1 et 5 séparés par un même pas
k=rep(1,30) #Créer un vecteur k contenant 1 répété 30 fois
gl(3,5) #Répéte tout les entiers de 1 à 3, 5 fois chacun
gl(2,6,label=c("homme","femme")) #Répéte "homme" et "femme" 6 fois chacun
l=f/3 #Créer un vecteur l où chaque éléments est la division par 3 d'un élément de f
f-3 #Soustrait 3 à tout les éléments de f
l+f #Additionne les éléments de l et f se trouvant sur la même position
l*f #Multiplie les éléments de l et f se trouvant sur la même position
l/f #Divise les éléments de l par ceux de f se trouvant sur la même position
sum(f) #Additionne tout les éléments de f
length(f) #Donne la longueur du vecteur f
t(f) #Donne la transposée du vecteur f (ici on obtient un vecteur ligne)
t(f)%*%l #Produit matriciel entre t(f) et l
#---------------------------------------
A=c(rep(1,5),seq(from=5,to=8,by=1),rep(12,2))
A
mode(A)
A.ch<-as.character(A) #Transforme tout les éléments de A en chaîne de caractères
A.fact<-as.factor(A) #Permet de définir des niveaux pour le vecteur A
#======================================
#2.2 Matrices
m1<-matrix(1:8, nrow=2) #Créer une matrice m2 avec 4 colonnes contenant tout les entiers de 1 à 8 placés de gauche à droite, en allant de haut en bas
m2<-matrix(1:8, ncol=4, byrow=T) #Créer une matrice m1 avec 2 lignes contenant tout les entiers de 1 à 8 placés de haut en bas en allant de gauche à droite
a<-1:20
m1<-matrix(a, nrow=5) #Créer une matrice m1 avec 5 lignes contenant tout les éléments de a placés de gauche à droite, en allant de haut en bas
m2<-matrix(a, nrow=5, byrow=T) #Créer une matrice m2 avec 5 lignes contenant tout les éléments de a placés de haut en bas en allant de gauche à droite
m3<-t(m1) #Créer la transposée de m1
m1; m2; m3 #Affiche m1, m2 et m3 en même temps
dim(m1) #Donne les dimensions de m1 (row col)
b<-m3%*%m2 #Effectue le produit matricielle entre m3 et m2. Il est possible
b<-m1%*%m2 #Effectue le produit matricielle entre m1 et m2. Il n'est pas possible
#====================================
#2.3 data.frame
X1=c(T,F,F,T,F)
X2=c(2,5,6,3,2)
X3=c("a", "b", "c", "i", "f")
mode(X1) ; mode(X2); mode(X3)
cbind(X1, X2, X3)
donnees=data.frame(X1, X2, X3)
str(donnees) #Etrange pour X3, je n'obtiens pas la même chose que le sujet
donnees[2:4, 2:3]
donnees$X1[1:3]
donnees$X2[c(1,3,5)]
#==================================
#2.4 Quelques fonctions usuelles
set.seed(123456)
y=rnorm(1000)
mean(y)
var(y)
sd(y) #Donne la racine carrée de var(y)
median(y) #Donne la valeur médiane de y
quantile(y) #Donne les quantiles de y
summary(y) #Donne les quantiles et la moyenne de y
hist(y) #Trace un histogramme avec comme ordonnée la fréquence
hist(y, probability=TRUE) #Trace un histogramme avec comme ordonnée la densité
curve(dnorm(x), add=TRUE) #Trace la courbe de la loi normale centrée réduite sur le dernier histogramme dessiné
boxplot(y) #Dessine la boîte à moustache de y
F=ecdf(y) #Calcul les valeurs de y si la simulation avait été faite avec la fonction de répartition
summary(F)
plot(F, main="Fonction de répartition empirique") #Dessine F
#---------------------------------
form1=1/1000*sum((y-mean(y))**2)
form2=1/999*sum((y-mean(y))**2)
var(y); form1; form2
#C'est la 2ème formule qui est utlisée
#================================
#3 Organisation
set.seed(123456)
X<-rnorm(n=100, mean=5, sd=2)
pdf(file="histX.pdf")
hist(X, probability=TRUE)
dev.off()
write.table(X, "donnees.txt")
read.table(file="donnees.txt")
#=================================
#4 Graphiques
X<-rnorm(n=1000, mean=5, sd=1)
Y<-rbinom(n=1000, p=0.4, size=1)
Z<-runif(n=1000, min=1, max=30)
stripchart(X)
hist(X, nclass=15, col="gray",border="red",main="Histogramme of X",xlab="X", ylab="",freq=FALSE)
stripchart(X, add=TRUE, at=0, pch=3, cex=0.5, col="blue")
curve(dnorm(x, mean=5, sd=1), add=TRUE, col="blue")
hist(Z, nclass=15, col="red",border="black", main="Histogramme of Z")
plot(X, Z)
abline(h=mean(Z), col="blue")
abline(v=mean(X), col="blue")
boxplot(X)
boxplot(X~Y)
plot(X~Y)
plot(Y~X)
plot(as.factor(Y)~X)
plot(as.factor(Y)~Z)
plot(X, Z, col=Y, pch=19)
plot(X, Z, col=as.factor(Y), pch=19)
grid(col="blue")
legend("bottomright", c("oui", "non"), pch=19, col=c("red", "black"))
#2.1 Vecteurs
a<-c(5.4,2.1,16,89) #Créer un vecteur a contenant 5.4,2.1,16 et 89
a #Donne les éléments de a
b<-c(a,6,1) #Créer un vecteur b contenant les éléments de a, puis 6, puis 1
d<-c(a,3,2,a) #Créer un vecteur d contenant les éléments de a, puis 3, puis 2, puis de nouveau les éléments de a
a[2] #Donne le 2ème élément du vecteur a
is.vector(a) #Renvoie TRUE si a est un vecteur, FALSE sinon
e<-a[2:4] #Créer un vecteur e contenant le 2ème, 3ème et 4ème éléments de a
f<-1:12 #Créer un vecteur f contenant tout les entiers de 1 à 12
f[2:3] #Donne les 2ème et 3ème éléments de f
f[5] #Donne le 5ème élément de f
f[-5] #Donne f privé de son 5ème élément
g<-c(3,6,1,"a") #Créer un vecteur g contenant "3", "6", "1" et "a" car "a" est une chaîne de caractère
g<-c(T,F,T,T) #Créer un vecteur g contenant TRUE, FALSE, TRUE, TRUE
mode(g) #Donne le type de g
h=seq(from=1,to=5,by=0.5) #Créer un vecteur h contenant tout les nombres entre 1 et 5 avec un pas de 0.5
h=seq(from=1,to=5,length=9) #Créer un vecteur h de longueur 9 contenant tout les nombres entres 1 et 5 séparés par un même pas
k=rep(1,30) #Créer un vecteur k contenant 1 répété 30 fois
gl(3,5) #Répéte tout les entiers de 1 à 3, 5 fois chacun
gl(2,6,label=c("homme","femme")) #Répéte "homme" et "femme" 6 fois chacun
l=f/3 #Créer un vecteur l où chaque éléments est la division par 3 d'un élément de f
f-3 #Soustrait 3 à tout les éléments de f
l+f #Additionne les éléments de l et f se trouvant sur la même position
l*f #Multiplie les éléments de l et f se trouvant sur la même position
l/f #Divise les éléments de l par ceux de f se trouvant sur la même position
sum(f) #Additionne tout les éléments de f
length(f) #Donne la longueur du vecteur f
t(f) #Donne la transposée du vecteur f (ici on obtient un vecteur ligne)
t(f)%*%l #Produit matriciel entre t(f) et l
#---------------------------------------
A=c(rep(1,5),seq(from=5,to=8,by=1),rep(12,2))
A
mode(A)
A.ch<-as.character(A) #Transforme tout les éléments de A en chaîne de caractères
A.fact<-as.factor(A) #Permet de définir des niveaux pour le vecteur A
#======================================
#2.2 Matrices
m1<-matrix(1:8, nrow=2) #Créer une matrice m2 avec 4 colonnes contenant tout les entiers de 1 à 8 placés de gauche à droite, en allant de haut en bas
m2<-matrix(1:8, ncol=4, byrow=T) #Créer une matrice m1 avec 2 lignes contenant tout les entiers de 1 à 8 placés de haut en bas en allant de gauche à droite
a<-1:20
m1<-matrix(a, nrow=5) #Créer une matrice m1 avec 5 lignes contenant tout les éléments de a placés de gauche à droite, en allant de haut en bas
m2<-matrix(a, nrow=5, byrow=T) #Créer une matrice m2 avec 5 lignes contenant tout les éléments de a placés de haut en bas en allant de gauche à droite
m3<-t(m1) #Créer la transposée de m1
m1; m2; m3 #Affiche m1, m2 et m3 en même temps
dim(m1) #Donne les dimensions de m1 (row col)
b<-m3%*%m2 #Effectue le produit matricielle entre m3 et m2. Il est possible
b<-m1%*%m2 #Effectue le produit matricielle entre m1 et m2. Il n'est pas possible
#====================================
#2.3 data.frame
X1=c(T,F,F,T,F)
X2=c(2,5,6,3,2)
X3=c("a", "b", "c", "i", "f")
mode(X1) ; mode(X2); mode(X3)
cbind(X1, X2, X3)
donnees=data.frame(X1, X2, X3)
str(donnees) #Etrange pour X3, je n'obtiens pas la même chose que le sujet
donnees[2:4, 2:3]
donnees$X1[1:3]
donnees$X2[c(1,3,5)]
#==================================
#2.4 Quelques fonctions usuelles
set.seed(123456)
y=rnorm(1000)
mean(y)
var(y)
sd(y) #Donne la racine carrée de var(y)
median(y) #Donne la valeur médiane de y
quantile(y) #Donne les quantiles de y
summary(y) #Donne les quantiles et la moyenne de y
hist(y) #Trace un histogramme avec comme ordonnée la fréquence
hist(y, probability=TRUE) #Trace un histogramme avec comme ordonnée la densité
curve(dnorm(x), add=TRUE) #Trace la courbe de la loi normale centrée réduite sur le dernier histogramme dessiné
boxplot(y) #Dessine la boîte à moustache de y
F=ecdf(y) #Calcul les valeurs de y si la simulation avait été faite avec la fonction de répartition
summary(F)
plot(F, main="Fonction de répartition empirique") #Dessine F
#---------------------------------
form1=1/1000*sum((y-mean(y))**2)
form2=1/999*sum((y-mean(y))**2)
var(y); form1; form2
#C'est la 2ème formule qui est utlisée
#================================
#3 Organisation
set.seed(123456)
X<-rnorm(n=100, mean=5, sd=2)
pdf(file="histX.pdf")
hist(X, probability=TRUE)
dev.off()
write.table(X, "donnees.txt")
read.table(file="donnees.txt")
#=================================
#4 Graphiques
X<-rnorm(n=1000, mean=5, sd=1)
Y<-rbinom(n=1000, p=0.4, size=1)
Z<-runif(n=1000, min=1, max=30)
<!-- stripchart(X) -->
hist(X, nclass=15, col="gray",border="red",main="Histogramme of X",xlab="X", ylab="",freq=FALSE)
stripchart(X, add=TRUE, at=0, pch=3, cex=0.5, col="blue")
curve(dnorm(x, mean=5, sd=1), add=TRUE, col="blue")
hist(Z, nclass=15, col="red",border="black", main="Histogramme of Z")
plot(X, Z)
abline(h=mean(Z), col="blue")
abline(v=mean(X), col="blue")
boxplot(X)
boxplot(X~Y)
plot(X~Y)
plot(Y~X)
plot(as.factor(Y)~X)
plot(as.factor(Y)~Z)
plot(X, Z, col=Y, pch=19)
plot(X, Z, col=as.factor(Y), pch=19)
grid(col="blue")
legend("bottomright", c("oui", "non"), pch=19, col=c("red", "black"))
bloxplot(Y)
boxplot(Y)
y
data=read.cav("ronflement.csv", header=TRUE, sep=";", dec=".")
data=read.cav("ronflement.csv", header=TRUE, sep=";", dec=".")
data=read.cav("ronflement.csv", header=TRUE, sep=";", dec=".")
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
q()
data=read.cav("ronflement.csv", header=TRUE, sep=";", dec=".")
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
data=read.csv("ronflement", header=TRUE, sep=";", dec=".")
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
getwd(/TD1Stats)
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
getwd(TD1Stats/)
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
getwd(TD1Stats/)
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
getwd(TD1Stats)
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
home()
home::home()
getwd(TD1Stats)
data=read.csv("ronflement.csv", header=TRUE, sep=";", dec=".")
getwd()
load("~/nutrimouse.rda")
install.packages("FactorMineR")
library("FactorMineR")
install.packages("factoextra")
library("factoextra")
#3)
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
library(FactoMineR)
library(factoextra)
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
res
#3)
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
res
View(data)
View(data)
View(nutrimouse)
install.packages("FactorMineR")
library("FactorMineR")
#3)
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
res
#3)
data <- cbind(nutrimouse$gene, as.factor(nutrimouse$genotype), as.factor(nutrimouse$diet))
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
#3)
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
getwd()
setwd(dir = "../Bureau/Master M1 MISO/Stats_S2/TP/")
#3)
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
res
getwd
getwd()
getwd()
knitr::opts_chunk$set(echo = TRUE)
load("nutrimouse.rda")
install.packages("FactorMineR")
install.packages(c("cli", "crayon", "digest", "dplyr", "fansi", "glue", "hms", "jsonlite", "knitr", "magrittr", "mime", "pillar", "Rcpp", "readr", "stringi", "tibble", "tinytex", "tzdb", "vroom", "xfun", "yaml"))
install.packages(c("cli", "crayon", "digest", "dplyr", "fansi", "glue", "hms", "jsonlite", "knitr", "magrittr", "mime", "pillar", "Rcpp", "readr", "stringi", "tibble", "tinytex", "tzdb", "vroom", "xfun", "yaml"))
install.packages(c("cli", "crayon", "digest", "dplyr", "fansi", "glue", "hms", "jsonlite", "knitr", "magrittr", "mime", "pillar", "Rcpp", "readr", "stringi", "tibble", "tinytex", "tzdb", "vroom", "xfun", "yaml"))
install.packages(c("cli", "crayon", "digest", "dplyr", "fansi", "glue", "hms", "jsonlite", "knitr", "magrittr", "mime", "pillar", "Rcpp", "readr", "stringi", "tibble", "tinytex", "tzdb", "vroom", "xfun", "yaml"))
install.packages(c("cli", "crayon", "digest", "dplyr", "fansi", "glue", "hms", "jsonlite", "knitr", "magrittr", "mime", "pillar", "Rcpp", "readr", "stringi", "tibble", "tinytex", "tzdb", "vroom", "xfun", "yaml"))
knitr::opts_chunk$set(echo = TRUE)
```{r}
load("nutrimouse.rda")
install.packages("FactorMineR")
library(factoextra)
library(FactoMineR)
detach("package:ggplot2", unload = TRUE)
library(ggplot2)
detach("package:factoextra", unload = TRUE)
library(factoextra)
detach("package:FactoMineR", unload = TRUE)
library(FactoMineR)
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
res <- PCA(data, quanti.sup=c(121,122), scale.unit=TRUE)
res
res <- PCA(data, quanli.sup=c(121,122), scale.unit=TRUE)
res <- PCA(data, quali.sup=c(121,122), scale.unit=TRUE)
res <- PCA(data, quali.sup=c(121,122), scale.unit=TRUE)
res
fviz_eig(res, addlabels=TRUE, main="Pourcentage d'inertie expliqué par chaque axe")
fviz_pca_ind(res, habillage=121)
fviz_contrib(res, choice="ind")
data <- cbind(nutrimouse$gene, nutrimouse$genotype, nutrimouse$diet)
res <- PCA(data, quali.sup=c(121,122), scale.unit=TRUE)
fviz_eig(res, addlabels=TRUE, main="Pourcentage d'inertie expliqué par chaque axe")
fviz_pca_ind(res, habillage=121)
fviz_pca_ind(res, habillage=122)
fviz_pca_ind(res, select.ind=list(contrib=sum(res$ind$contrib[,1]>25)))
fviz_pca_ind(res, habillage=122, select.ind=list(contrib=sum(res$ind$contrib[,1]>25)))
fviz_pca_ind(res, habillage=122, select.ind=list(contrib=sum(res$ind$contrib[,1]>2.5)))
fviz_pca_ind(res, select.ind=list(contrib=sum(res$ind$contrib[,1]>2.5)))
dimescrip
?dimescrip
??dimescrip
??dimescrip()
dimdescrip()
dimdescript()
fviz_contrib(res, choice="var")
fviz_pca_ind(res, select.ind=list(contrib=sum(res$var$contrib[,1]>0.8)))
?dimdesc
dimdesc(res, axes=1:2)
rmarkdown::paged_table(data.frame(dimdescrip$Dim.1$quanti[dimdescrip$Dim.1$quanti[,1]>0.6])
rmarkdown::paged_table(data.frame(dimdescrip$Dim.1$quanti[dimdescrip$Dim.1$quanti[,1]>0.6]))
dimdescrip <- dimdesc(res, axes=1:2)
rmarkdown::paged_table(data.frame(dimdescrip$Dim.1$quanti[dimdescrip$Dim.1$quanti[,1]>0.6]))
